//char的截断与提升

#include <stdio.h>
#include <stdlib.h>

int main()
{
	char a = -128;
	//此处是截断，-128本身是int类型
	//原码是10000000 00000000 00000000 10000000
	//反码是11111111 11111111 11111111 01111111
	//补码是11111111 11111111 11111111 10000000
	//此时小端机中存储的是0x80 ff ff ff，截断时截取第一段，即80
	//即此时的a = 10000000
	printf("%u\n", a);
	//输出%u无符号整形时需要a从char提升为int
	//提升的规则是有符号数补符号位，无符号数补0，即为
	//11111111 11111111 11111111 10000000
	//所以此时输出应为2^32-127

	//另一个问题
	char b = 128;
	printf("%u\n", b);
	//b是一个正数，截断同上得到b = 10000000
	//但是此时注意提升时读的是自己的符号位，即为1，即全补1
	//输出同-128一致为 11111111 11111111 11111111 10000000

	unsigned char c = 128;
	printf("%u\n", c);
	//此时用了无符号整形unsigned，所以应补0，即为
	//00000000 00000000 00000000 10000000

	unsigned char d = -128;
	printf("%u\n", d);
	//-128截断后依然是10000000，无符号依旧补0
	//00000000 00000000 00000000 10000000

	system("pause");
}